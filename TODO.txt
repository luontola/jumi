
OK - JUnit backward compatibility
	OK - run JUnit 3 tests
		OK - create CompositeDriverFinder
			OK - refactor RunViaAnnotationDriverFinder to return null if the class was unsupported
		OK - create JUnitDriverFinder
		OK - plug in, ignore if JUnit not on classpath: DriverFinderFactory
		OK - give Jumi the highest priority
		OK - rename all classes to use JUnitCompatibility* prefix, to assist code completion
		OK - implement JUnitCompatibilityDriver
	OK - run JUnit 4 tests
	SKIP - should we support for all that's in org.junit.internal.builders.AllDefaultPossibilitiesBuilder?
		SKIP - classes annotated with @Ignore: the common case is that the class contains @Test methods and that's already detected
		SKIP - classes with static suite() methods: JUnit 3 is very old and the migration of Suites to JUnit 4 is easy enough
	OK - JUnit 3 support should only check for junit.framework.TestCase
		org.junit.internal.builders.JUnit3Builder
		OK - change fi.jumi.core.drivers.JUnitCompatibilityDriverFinder#JUNIT_3_TEST, rename to JUNIT_3_TEST_CASE
		OK - remove fi.jumi.core.drivers.JUnitCompatibilityDriverFinderTest.JUnit3Suite
	OK - pull the use of PackageNonDelegatingClassLoader from JUnitCompatibilityDriverFinder into DriverFinderFactory; load whole JUnitCompatibilityDriverFinder dynamically
	OK - run JUnit 4 custom runner tests
		OK - end-to-end test: use org.junit.runners.Suite to cover also nested tests
		OK - JUnitCompatibilityDriverFinder#isJUnit4AnnotatedTest
		OK - improve the driver
	OK - JUnitCompatibilityDriver:
		OK - multiple test methods
		OK - deep test hierarchies
		OK - refactor Description-TestId mapping to use recursion
		OK - failures (create end-to-end test)
		OK - ignored tests (null implementation at first)
		OK - assumptions (null implementation at first)
		OK - tests discovered after starting the test run
		OK - free-form test names
	OK - remove debug printing from JUnitRunListenerAdapter
	SKIP - report JUnit test mechanism failures to Jumi (or do this after we have support in Jumi for reporting internal errors?)

OK - set context class loader for test threads
	OK - end-to-end test
	OK - unit test
		OK - extract wiring from Main
		OK - make the thread pools testable
		OK - check the context class loader of the pool
	OK - verify that fixes https://github.com/orfjackal/jumi/issues/2
	OK - e2e test for also driver thread; it may change in the future
		OK - run tests annotated @SimpleUnit.RunInDriverThread without the Executor
		OK - similar test as for the test thread, but with the annotation
		OK - also make the tests print the current thread, and assert (?) that what it is (test vs actor thread), to know when it changes

OK - deadlock in printing to standard output
	https://github.com/orfjackal/jumi/issues/3
	analysis:
		1. Throwable.printStackTrace locks on StderrProxy, then uses StderrProxy.y() thus locking SynchronizedPrintStream
		2. somebody uses StderrProxy.x() thus locking SynchronizedPrintStream, which invokes StderrProxy.super.x() thus locking StderrProxy
	OK - reproduce with a unit test: one thread locks PrintStream and then prints, another thread just prints
	OK - fix idea: synchronize on obj before locking in fi.jumi.core.output.SynchronizedPrintStream.SynchronizedMethodInterceptor#intercept
	OK - verify that fixes https://github.com/orfjackal/jumi/issues/3

OK - consider preventing Throwable.printStackTrace() from being wrapped around System.out.print()
	For the common case "synchronized(System.err){}" we could make all actions on System.out to lock System.err's monitor after locking System.out's monitor. Only one direction is possible without deadlock.
	Locking order: System.out -> System.err -> shared lock (though shared lock then not necessary)
	OK - write unit test: one thread calls Throwable.printStackTrace(err), another prints garbage to out (start first & end last), check that result contains stack trace coherently
	OK - change fi.jumi.core.output.SynchronizedPrintStream#create to take an Object to lock on instead of ReentrantLock
	OK - update SynchronizedPrintStreamTest to use Thread#holdsLock instead of ReentrantLock#isHeldByCurrentThread
	OK - pass the other PrintStream as the object to lock on to the other
	OK - probably only one of them needs to be a proxy
	OK - consider customizing SynchronizedPrintStream's Enhancer
		OK - improve thread dumps with setNamingPolicy: extend DefaultNamingPolicy, override prefix: super.getClassName(SynchronizedPrintStream.class.getName(), source, key, names)
		OK - harden the interface with setUseFactory(false): create a new Enhancer for each create() (it anyways has internal cache)

OK - end-to-end tests: reporting failures outside tests (in drivers and core)
	OK - exceptions from actors
		OK - test: malformed .class file
		OK - create SuiteListener event
		OK - ui: print internal errors
		OK - ui: make the suite fail on internal error (TextUI#hasFailures returns false)
		SKIP - implement ui parsing, or do the end-to-end tests already have what they need?
		OK - hook into the actors
	SKIP - double-check that implemented:
		fi.jumi.core.results.SuiteEventDemuxer.InternalDemuxer#onInternalError
	OK - exceptions from test threads
		OK - test: throw exception from a driver
		OK - test: throw exception from test Executor, without the driver catching it
		OK - create InternalErrorReportingExecutor
		OK - the e2e tests are flaky; the suite ends (onSuiteFinished) before the internal error is reported
			OK - prepare for inlining/heavy refactoring of SuiteRunner
				OK - SuiteRunnerIntegrationHelper: use TestBench instead of SuiteRunner directly
					OK - TestBench: allow injecting SuiteListener, instead of hiding it behind SuiteEventDemuxer
			OK - move the reporting layer below WorkerCounter instead of above it? do this first and then refactor mercilessly?
			SKIP - try extracting from SuiteRunner the code that deals with WorkerCounter into an injectable object?
				runWorker((executor) -> new TestFileFinderRunner(testFileFinder, actorThread.bindActor(TestFileFinderListener.class, this)))
				runWorker((executor) -> driverFactory.createDriverRunner(testFile, executor))
			SKIP - move worker counting and onSuiteStarted/onSuiteFinished calls to SuiteFactory?
			OK - extract TestFileFinderListener implementation from SuiteRunner, to create TestFileRunner and remove SuiteRunner? would also remove StubTestFileFinder (injected to SuiteRunner in TestBench)
				OK - add TestFileFinderListener.onAllTestFilesFound()
				OK - don't use WorkerCounter for TestFileFinderRunner, but use a flag SuiteRunner.allTestFilesStarted
				OK - rename SuiteRunner.childRunners to activeTestFiles
				OK - move starting TestFileFinderRunner out of SuiteRunner, maybe to its own actor thread (which is stopped after it finishes)
				OK - call fi.jumi.actors.workers.WorkerCounter#afterPreviousWorkersFinished in onAllTestFilesFound, remove the separate counting?
		OK - extract base class for InternalErrorReportingExecutor & InternalErrorReportingFailureHandler
		SKIP - refactor SuiteFactory: move MessageListener construction out of start()?
	OK - report JUnit test mechanism failures to Jumi
		OK - add fireInternalError to SuiteNotifier
		OK - write a test using a custom JUnit runner that repots test mechanism error with RunNotifier#fireTestFailure
		OK - implement JUnitTestMechanismFailureReporter
	OK - refactor test file finders
		OK - PathMatcherTestFileFinder: send onAllTestFilesFound()
			OK - also update others, such as CompositeTestFileFinderTest.FakeTestFileFinder
		OK - CompositeTestFileFinder: pass to the finders a proxy listener (wrapped in ActorRef) which counts how many times onAllTestFilesFound() was used and hides all but last
	OK - give an error message if starting the daemon fails (for example out of memory; maybe testable with bad JVM options)
		OK - end-to-end test
		OK - create InitialMessageTimeout
		OK - hook into ProcessStartingDaemonSummoner or RemoteSuiteLauncher; send onSuiteStarted, onInternalError, onSuiteFinished
			OK - unit test
			OK - OneTimeDaemonListenerFactory: push listener.tell() outside the constructor, should make the timeout easier
			OK - hack InitialMessageTimeout in; first make it work
			FAIL - consider generating eventizers instead of using dynamic eventizers
			SKIP - (would it be cleaner if InitialMessageTimeout were a dynamic proxy that forwards any method calls? smells like re-inventing dynamic eventizers)
		SKIP - show the message printed by the JVM
		OK - refactor ProcessStartingDaemonSummonerTest
		OK - write a unit test that the normal events are forwarded from daemon to daemon listener
	OK - TextUI fine tuning
		OK - reformat: " > Internal Error\n > ..."
		OK - no need for the total test count
		OK - show in the summary: "There were internal errors"
		OK - show in the summary: "There were test failures"

OK - daemon idle timeout could be 0, increase it only for tests that require a larger value (if any)

OK - ui: give a warning if a test spawned a thread which prints something after the test ended (but don't hide the output)
	OK - suite mother: test that prints to out & err after ending
	SKIP - ui: print a warning line, but only once " > Warning: Continued printing after the test run finished"
	OK - annotate as @CheckForNull the relevant TestId parameters in RunVisitor?
	OK - verify that fixes https://github.com/orfjackal/jumi/issues/1

!! - skip abstract test classes silently
	OK - end-to-end test
	OK - find out how Surefire does it; should also interfaces have special handling?
		~ subclasses of org.apache.maven.surefire.util.ScannerFilter only check "!Modifier.isAbstract(testClass.getModifiers())" (plus JUnit annotations etc.)
		~ but Modifier.isAbstract() returns false also for interfaces, so we don't need to check interfaces separately
		~ ignores files that match the name pattern, but don't have @Test/@RunWith etc.
			"This is the second most popular issue for Surefire"
			http://jira.codehaus.org/browse/SUREFIRE-482
	!! - IgnoreSilentlyDriverTest: test that does nothing to the args when called
	- DriverFinderFactoryTest: abstract class annotated with @RunVia, should use IgnoreSilentlyDriver
	- DriverFinderFactoryTest: concrete class with no annotations or other stuff, should use IgnoreSilentlyDriver
		- write also as end-to-end test
		- print a warning maybe? nagging the users indefinitely about intentional use is bad, so only show the warning in daemon logs
			~ Surefire gives an error for such classes if the "-Dsurefire.junit4.upgradecheck" flag is set (see org.apache.maven.surefire.junit4.JUnit4Provider#upgradeCheck and http://maven.apache.org/surefire/maven-surefire-plugin/examples/junit.html)
	- verify that fixes https://github.com/orfjackal/jumi/issues/4

- configurable thread count
	- add configuration parameter (DaemonConfiguration) for the number of test threads
	- make the number of test threads by default the number of CPUs + 1 or similar

- release 0.4
	- tidy up release notes
	OK - bump version
	- release
	- web site: feature list on front page, project goals/principles/values maybe moved to wiki
	- create a performance comparison (e.g. with Dimdwarf's tests)
	- promote widely

- plugin system for custom DriverFinders
	- hook into fi.jumi.core.drivers.DriverFinderFactory
	- move JUnit compatibility into its own module
		- create jumi-junit.jar
		- extract it automatically to ~/.jumi/plugins, the same way as the daemon jar
		- load it (and other plugins) in the test classloader
	- refactor JUnitCompatibilityDriverFinder et al to avoid reflection
	- refactor tests that use JUnitCompatibilityDriver.class.getName() instead of instanceOf checks (in DriverFinderFactoryTest)
	- investigate maven-shade-plugin; can we now turn on minimizing? it used to remove the JUnitCompatibilityDriver from jumi-daemon.jar
		- experiment:
			- how much is daemon jar minimized? if it minimizes only a little, it might not be worth it
			- write a test that the daemon jar contains everything from the jumi-core

- ignoring tests
	- ignoring without running a test
	- ignoring after test has started
	- JUnit @Ignore
		- update the test in fi.jumi.test.JUnitCompatibilityTest
		- implement fi.jumi.core.junit.JUnitRunListenerAdapter#testIgnored (JUnitCompatibilityDriverTest)
	- JUnit assumptions
		- update the test in fi.jumi.test.JUnitCompatibilityTest
		- implement fi.jumi.core.junit.JUnitRunListenerAdapter#testAssumptionFailure (JUnitCompatibilityDriverTest)

- release 0.5
	- tidy up release notes
	- bump version
	- release
	- promote

- make option 2 explicit by adding a test for it; check for "nihao: ??" and "umlauts: ???" on US-ASCII
	> - when default charset is ISO-8859-1 (fi.jumi.test.StandardOutputTest#compensates_for_the_default_charset_of_the_daemon_process), Unicode chars are lost already when they are captured (nihao becomes ??); should we do something about it?
	>	(1) We could have an internal PrintStream which uses UTF-8/16 and capture losslessly from it, after which it's routed to a PrintStream which uses the actual encoding (might interfere with writing binary data to stdout).
	>	(2) Or then keep it as is. That would be the way that System.out works normally. Principle of least surprise?

- misc refactoring (choose some, defer others)
	- DaemonConfiguration: refactor the code for parsing command line parameters
		fi.jumi.core.config.DaemonConfigurationBuilder#parseProgramArgs
		fi.jumi.core.config.DaemonConfiguration#toProgramArgs
		fi.jumi.core.config.DaemonConfiguration#JUMI_HOME and other constants
	- thread-safety-checker: when an inner class is missing the annotation, use the annotation of the enclosing class or default to @NotThreadSafe when the enclosing class has any concurrency annotation
	- replace SuiteRunnerIntegrationHelper with TestBench?
	- consider implementing SynchronizedPrintStream using something else than CGLIB (ASM? Tapestry's Plastic?) to make the JAR smaller
	- after upgrading to (presumably) JUnit 4.11, refactor BuildTest's parameterized descriptions
		https://github.com/KentBeck/junit/pull/145
		https://github.com/KentBeck/junit/pull/393
		- also use junit:junit instead of junit:junit-dep, since it's now a proper Maven artifact
	- check whether we still have many ASM versions we have on classpath (caliper depends on ASM 3), block "asm:*" artifacts with maven-enforcer-plugin?
	- make JUnit print a thread dump when a test times out due to @Test(timeout)
		- improve JUnit's test timeouts to show a stack trace of the timed out test, to help debugging sporadic timeouts in RunningTestsTest
	- evaluate whether some of the concurrent tests could be made simpler by using MultithreadedTC
		http://code.google.com/p/multithreadedtc/
	- BuildTest: make sure that jumi-daemon.jar contains everything from jumi-api.jar no matter what
		- test the test by adding an unused class to jumi-api
		- add includes if necessary: http://maven.apache.org/plugins/maven-shade-plugin/examples/includes-excludes.html
	- fix Maven's pomPropertiesFile element, get rid of the current workaround of a separate build.properties
		http://jira.codehaus.org/browse/MSHARED-154
		http://stackoverflow.com/questions/10102818/custom-values-in-maven-pom-properties-file
		<archive> element: http://maven.apache.org/plugins/maven-jar-plugin/jar-mojo.html
		<pomPropertiesFile> element: http://maven.apache.org/shared/maven-archiver/index.html
	- unit tests for fi.jumi.core.results
	- combine DuplicateOnTestFoundEventFilter and SuiteListenerAdapter, rename to SuiteEventNormalizer/RunEventNormalizer
	- DuplicateOnTestFoundEventFilterTest: generic test for all events that are forwarded as-is
	- there might be unnecessary eventizers in fi.jumi.daemon.Main and /jumi-core/pom.xml
		- create EventizerUsageStatistics (extends EventizerProvider), print usage statistics when program exits
	- organize the project so that it's possible to run unit tests separate from end-to-end tests
		- put end-to-end tests in their own package, test.fi.jumi?
		- or use JUnit categories, maybe with a custom runner?
		- or use ClasspathSuite?
	- bullet proofing the public api, cross-references from javadocs to tests (a new xref tag?)
		- testId in onTestFinished must be correspond last onTestStarted, correctly nested
		- testId in onFailure must equal the currently running test
		- disallow TestNotifier.fireFailure and fireTestFinished after test is finished
		- log all incorrect usages to some internal log and make the suite fail?
		- TestClassListener: consider eliminating redundant parameters
	- evaluate JarJar or ProGuard, maybe it could minimize the jars better than the shade plugin by removing also unused methods
		http://sonatype.github.com/jarjar-maven-plugin/
		http://pyx4me.com/pyx4me-maven-plugins/proguard-maven-plugin/
		https://github.com/wvengen/proguard-maven-plugin (uses newer version of ProGuard)
		1. run shade plugin to embed all dependencies and create the dependency-reduced POM
		2. run proguard to minimize the JAR at method level and preverify (in and out files must be different?)
		3. replace the main artifact
			http://mojo.codehaus.org/build-helper-maven-plugin/attach-artifact-mojo.html
	- consider logging with MinLog http://code.google.com/p/minlog/
		or create our own clone, since it's just one file (and )
		- actors: extract AbstractMessageLogger from PrintStreamMessageLogger
		- create logger specific implementation of AbstractMessageLogger
		- customize MinLog's output to use microsecond accuracy, similar to PrintStreamMessageLogger

- write daemon output to log file
	- use ProcessBuilder.redirectOutput to write the log file (else the process would hang when the launcher JVM exits)
		- write log to JUMI_HOME/run/*/console.log
		- default JUMI_HOME to ~/.jumi
	- update e2e tests to read the output from the log file
	- get rid of fi.jumi.launcher.remote.ProcessStartingDaemonSummoner#copyInBackground
		- don't create background threads in the launcher automatically (the tests should create them explicitly, if any)
		- also remove the hack in fi.jumi.test.ReleasingResourcesTest#launcher_stops_the_threads_it_started
	- update ErrorHandlingTest#gives_an_error_if_starting_the_daemon_process_failed
		- show the path to the daemon log file in the error message

- minor release 0.5
	- tidy up release notes
	- release
	- promote

- end-to-end tests: persistent daemon process
	- spike communicating over memory-mapped files (see below)
	- should drive better design on launcher side
	- connect to existing process
		- cancel idleTimeout if somebody connects again (unit test only?)
	- if daemon dies unexpectedly (System.exit/halt, JVM crash etc.), report it and restart next time
		http://vanillajava.blogspot.com/2011/12/test-complete-failure-of-jvm.html
	- how to show unfinished test runs in the TextUI? (both JVM crash unfinishing all tests, and buggy testing framework unfinishing some tests)
	- if daemon disconnects due to network problem, reconnect and resume where we were left?
		- should not exit the JVM (due to idle timeout) while tests are running
	- make it reliable

- communicate using memory-mapped files?
	http://en.wikipedia.org/wiki/Memory-mapped_file
	http://javarevisited.blogspot.fi/2012/01/memorymapped-file-and-io-in-java.html
	http://stackoverflow.com/questions/5943365/java-tcp-ip-socket-latency-stuck-at-50-s-microseconds-used-for-java-ipc
	http://stackoverflow.com/questions/6096485/how-to-dynamically-expand-a-memory-mapped-file
	https://github.com/peter-lawrey/Java-Chronicle (see how IPC is done here)
	- benefits:
		- more secure than sockets (uses file system permissions)
		- should be faster (benchmark latency and throughput)
		- automatically saved to file for later use
		- no need to close socket connections
		- no need for a networking library
	- disadvantages:
		- how to manage multiple writers? one file per writer?
		- probably requires polling to get informed about updates
	- need to find out how to do synchronization
		http://stackoverflow.com/questions/4743380/controlling-read-writes-to-memory-mapped-files-windows
	- after implementing, consider refactoring the following places:
		fi.jumi.core.TestRunCoordinator#addSuiteListener
		fi.jumi.daemon.DaemonNetworkEndpoint#onConnected
		fi.jumi.launcher.remote.RemoteSuiteLauncher#onDisconnected

- run tests in a loop on a weakly ordered, multi-core CPU, to look for cache coherency issues
	- where to find a multi-core ARM for a test drive?
		http://www.calxeda.com/trystack/
		http://trystack.org/

- release 0.6
	- tidy up release notes
	- bump version
	- release
	- create a performance comparison (e.g. with Dimdwarf's tests)
	- promote widely

- deployment pipeline
	jumi:
		build
			build-release
		analyze
			coverage-report
	jumi-integration:
		test
			integration-test
	jumi-publish:
		publish [M]
			push-staging
			promote-staging
			smoke-test
			promote-central
		announce [M]
			update-www
			send-emails
	- create jumi-integration and add it to the pipeline
		- integration tests for Specsy
		- platform for running the tests
		- run an untrusted go-agent in a restricted environment
		- add it to the pipeline
	- push-button releasing the staging repository
		- run smoke tests before promoting
		- if smoke tests pass, promote automatically from OSSRH to Central
			- consider migrating to nexus-staging-maven-plugin, https://github.com/sonatype/nexus-maven-plugins/tree/master/nexus-staging-maven-plugin
			http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html
			https://repository.sonatype.org/content/sites/maven-sites/nexus-maven-plugin/
	- automate updating the web site
		- update the version number of latest release to the web site
		- update javadocs to the web site

- web site improvements
	- site for jumi-actors-maven-plugin
		http://www.vineetmanohar.com/2009/04/how-to-auto-generate-maven-plugin-documentation/
		http://stackoverflow.com/questions/2912665/maven-plugin-site
		http://maven.apache.org/guides/mini/guide-site.html
	- aggregated javadoc of all modules?
		http://maven.apache.org/plugins/maven-javadoc-plugin/aggregate-mojo.html

- improving TextUI
	(- if multiple readers are needed: Streamer class for receiving events from UI thread)
	- different colors for out (default), err (red), metadata e.g. test names (blue), binary output (yellow BG)?
		- JCons (uses JNI on Windows, so maybe support only Unix)
			http://jcons.sourceforge.net/
			http://sourceforge.net/projects/jcons/
		- could also JLine do it? (uses a native binary)
			http://jline.sourceforge.net/
			https://github.com/jline
		- misc links
			http://www.codeguru.com/forum/showthread.php?t=504096
			http://blogs.atlassian.com/2009/10/colour_your_console_ansicolor/
			http://en.wikipedia.org/wiki/ANSI_escape_code
			http://www.velocityreviews.com/forums/t143949-text-color-in-windows-console.html
			http://academic.evergreen.edu/projects/biophysics/technotes/program/ansi_esc.htm
			http://www.tldp.org/LDP/abs/html/colorizing.html
			http://stackoverflow.com/questions/7445658/how-to-detect-if-the-console-does-support-ansi-escape-codes-in-python
		- ANSI escape codes work in IDEA?
			http://youtrack.jetbrains.net/issue/IDEA-68679

- write performance tests
	- test: suite with a hundred test classes, each with a hundred tests, some of which also do printing; measure total time of running the suite
	- experiment with different queue implementations, for example ConcurrentLinkedQueue
	- try following the single writer principle: http://mechanical-sympathy.blogspot.com/2011/09/single-writer-principle.html
		- for example: separate queue for each test worker (implies parallelism = locally sequential, except for slow tests?, use a work stealing executor?) and one thread which loops through them and writes to the coordinator actor queue

- "Error creating shaded jar", probably an issue with NTFS's pending delete and the shade plugin
	- make a bug request, maybe also a patch
	http://mail-archives.apache.org/mod_mbox/maven-dev/200808.mbox/%3C835d522e0808281121g47eedd04u3c056998569be860@mail.gmail.com%3E

- investigate warnings on build:
	- happens when jumi-core-0.1.0-SNAPSHOT.jar (or daemon JAR) exists from the previous build
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TailerListener.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TailerListenerAdapter.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TeeInputStream.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/XmlStreamReader.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar

- Pronouncing Jumi: ['jumi]
	http://en.wikipedia.org/wiki/International_Phonetic_Alphabet
